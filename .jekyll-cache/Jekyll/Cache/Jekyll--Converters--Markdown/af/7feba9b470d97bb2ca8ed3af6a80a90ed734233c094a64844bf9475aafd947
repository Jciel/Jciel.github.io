I"Òf<p><br /></p>

<p>Seguindo a s√©rie de trabalhos da faculdade :D, agora brincando um pouco 
com Machine Learning.</p>

<p><br /></p>

<p>Classifica√ß√£o de textos consiste em associar cada texto a uma determinada classe 
baseada em seu conte√∫do, por exemplo, podemos associar um coment√°rio 
sobre um produto ou servi√ßo a uma classe ‚ÄúNegativo‚Äù quando for um 
coment√°rio negativo sobre o produto ou a uma classe ‚ÄúPositivo‚Äù quando 
for um coment√°rio positivo sobre o mesmo.</p>

<p>Isso acontece tamb√©m nos servidores de e-mails para poder classificar 
um e-mail como spam, por exemplo, e assim direcion√°-lo para o diret√≥rio 
spam.</p>

<p><img src="https://cdn-images-1.medium.com/max/1371/1*6h-IqXpvLbQemIRedaCrMg.png" alt="" /></p>
<div class="img-legend"><a href="https://cdn-images-1.medium.com/max/1371/1*6h-IqXpvLbQemIRedaCrMg.png">Fonte</a></div>

<p><br /></p>

<p>Fazer isso a uma quantidade grande de coment√°rios pode ser √∫til para se 
ter uma vis√£o de como as pessoas, possivelmente os clientes ou usu√°rios, 
est√£o se sentindo em rela√ß√£o a um produto, por exemplo, mas pode ser 
trabalhoso e talvez invi√°vel fazer isso manualmente, ai entra o Machine 
Learning para automatizar esse processo.</p>

<p>Para utilizar Machine Learning na classifica√ß√£o de textos, uma das 
t√©cnicas mais utilizadas √© usar aprendizado supervisionado, onde temos 
uma cole√ß√£o de dados j√° processados e classificados nas suas 
determinadas classes, ent√£o entramos esses dados como input para o 
algoritmo que ir√° ‚Äòaprender‚Äô as caracter√≠sticas que representam cada 
classe com utilizando esses dados j√° classificados.</p>

<p>Os problemas mais frequentes que fazem uso de aprendizado supervisionado 
s√£o problemas de ‚Äòregress√£o‚Äô onde temos que mapear as vari√°veis em um 
resultado continuo, tentando predizer um resultado, e problemas de 
‚Äòclassifica√ß√£o‚Äô, que ser√° o caso de estudo, que se pretende definir 
classes distintas √†s vari√°veis de entrada que no caso ser√£o coment√°rios 
sobre filmes.</p>

<p>Para implementar um modelo de Machine Learning normalmente segue-se um 
fluxo, que pode variar dependendo do objetivo final, em cima dos dados 
antes que o modelo entre em produ√ß√£o, que podemos definir basicamente em:</p>

<ul>
  <li>Obten√ß√£o dos dados;</li>
  <li>Pr√©-processamento;</li>
  <li>Treinamento;</li>
  <li>Teste;</li>
  <li>Aperfei√ßoamento;</li>
</ul>

<p><img src="https://cdn-images-1.medium.com/max/800/1*PAqzvCxPjpDN8RC9HQw45w.jpeg" alt="" /></p>
<div class="img-legend"><a href="https://cdn-images-1.medium.com/max/800/1*PAqzvCxPjpDN8RC9HQw45w.jpeg">Fonte</a></div>

<p><br />
<br /></p>

<h3 id="obten√ß√£o-dosdados"><strong>Obten√ß√£o dos¬†dados</strong></h3>
<div class="img-container">
    <img src="https://image.ibb.co/czGAs8/getData.jpg" />  
</div>

<p>Nesta etapa obtemos os dados ‚Äúcrus‚Äù seja de qualquer fonte, banco de 
dados, arquivos, paginas web, etc. √â importante saber que os dados devem 
ser relevantes para o dom√≠nio do problema, selecionando dados diferentes 
do que se deseja analisar pode prejudicar o resultado final e trazer 
resultados incoerentes com a realidade.</p>

<p>Para este caso eu realizei <em>scraping</em> (<em>web scraping</em> √© uma t√©cnica para 
captura automatizada de dados de p√°ginas web, sejam textos, imagens, documentos, etc.) 
de um site sobre cinema e peguei os coment√°rios das pessoas que fizeram 
avalia√ß√µes de diversos filmes. Como no site tinha a avalia√ß√£o dos 
determinados filmes em forma de estrelas, assumi isso para determinar se 
um coment√°rio √© <code class="language-plaintext highlighter-rouge">positivo</code> ou <code class="language-plaintext highlighter-rouge">negativo</code>, para ficar mais 
discretizado descartei os coment√°rios com 3 estrelas por assumir que 
seriam ‚Äúneutros‚Äù, e defini os coment√°rios com 4 e 5 estrelas como 
positivos e os que tiveram 2 ou 1 estrelas como negativo, ent√£o salvei 
em dois arquivos separados <code class="language-plaintext highlighter-rouge">CommentsPositive</code> e <code class="language-plaintext highlighter-rouge">CommentsNegative</code>.</p>

<p><br /></p>

<h3 id="pr√©-processamento"><strong>Pr√©-processamento</strong></h3>
<div class="img-container">
    <img src="https://image.ibb.co/dLAs5T/preprocessor.jpg" />
</div>

<p>Nesta etapa realizamos a prepara√ß√£o dos dados, padronizando, retirando 
inconsist√™ncias, etc, para ap√≥s servir como entrada para o treinamento 
do algoritmo. Esse processo pode ser composta de diversas sub etapas que 
podem variar dependendo do objetivo final e necessidade. Para esse caso 
de estudo fiz as seguintes sub-etapas para preparar os dados:</p>

<h5 id="padronizar-tudo-em-letra-min√∫sculas"><strong>Padronizar tudo em letra min√∫sculas</strong></h5>
<p>Como processo de padroniza√ß√£o dos coment√°rios transformei tudo em letras 
min√∫sculas;</p>

<h5 id="remo√ß√£o-deacentos"><strong>Remo√ß√£o de¬†acentos</strong></h5>
<p>Tamb√©m removi toda a acentua√ß√£o dos coment√°rios;</p>

<h5 id="remo√ß√£o-de-pontua√ß√£o"><strong>Remo√ß√£o de pontua√ß√£o</strong></h5>
<p>As pontua√ß√µes n√£o t√™m significado para este caso ent√£o foi removido todo 
tipo de pontua√ß√µes;</p>

<h5 id="remo√ß√£o-de-espa√ßos-embranco"><strong>Remo√ß√£o de espa√ßos em¬†branco</strong></h5>
<p>Foi removido todo espa√ßo em branco desnecess√°rio;</p>

<h5 id="remo√ß√£o-de-caracteres-repetidos"><strong>Remo√ß√£o de caracteres repetidos</strong></h5>
<p>Tamb√©m foi removidos caracteres repetidos, por exemplo, o seguinte 
coment√°rio: ‚Äúfilme muuuuuuiiitttooooo boooooooommmmm‚Äù, foi transformado 
em: ‚Äúfilme muito bom‚Äù;</p>

<h5 id="remo√ß√£o-de-stopwords"><strong>Remo√ß√£o de stopwords</strong></h5>
<p>Esta √© uma t√©cnica muito utilizada no pr√©-processamento de textos para 
classifica√ß√£o com Machine Learning, consiste na remo√ß√£o de palavras 
muito frequentes e que n√£o s√£o tenham nenhum valor sem√¢ntico no texto, 
como exemplo os artigos e preposi√ß√µes, isso tamb√©m diminui a quantidade 
de palavras a serem processadas melhorando o tempo da tarefa de 
treinamento e teste;</p>

<h5 id="stemming"><strong>Stemming</strong></h5>
<p><em>Stemming</em> tamb√©m √© um m√©todo bastante utilizado em textos antes de serem 
processado por algum algoritmo de Machine Learning.</p>

<p>Os textos comumente possuem diversas palavras derivadas ou flexionadas, 
o processo de stemming reduz todas as palavras poss√≠veis ao seu radical, 
removendo prefixos e sufixos derivados de um mesmo radical, ajudando a 
diminuir a dimensionalidade do processamento do texto porque palavras 
diferentes derivadas de um mesmo radical, ambas passam a ser 
representada pelo radical, como, por exemplo: ‚Äútestando‚Äù e ‚Äútestado‚Äù 
passam a ser o radical ‚Äútest‚Äù ambas as palavras t√™m o mesmo valor 
sem√¢ntico.</p>

<p>Nesse processo podem ocorrer alguns erros como ‚ÄúOverstemming‚Äù e 
‚ÄúUnderstemming‚Äù.</p>

<p><em><strong>Overstemming</strong></em> acontece quando o processo retira caracteres que n√£o 
fazem parte de uma flex√£o ou deriva√ß√£o da palavra, mas fazem parte do 
radical. Pode resultar em um mesmo radical para palavras distintas.</p>

<p><em><strong>Understemming</strong></em> ocorre quando ainda sobram caracteres de deriva√ß√£o 
ou flex√£o da palavra ap√≥s o processo de stemming. Podendo resultar em 
radicais distintos para palavras de mesma origem.</p>

<p><br /></p>

<h3 id="o-algoritmo-e-treinamento"><strong>O algoritmo e treinamento</strong></h3>
<div class="img-container">
    <img src="https://image.ibb.co/mvzGzo/train.png" />
</div>

<p>Antes de fazer o treinamento precisamos do algoritmo para treinar. Um 
dos algoritmos mais utilizados em problemas de classifica√ß√£o √© o 
‚ÄòNaive Bayes‚Äô, baseado no teorema de Bayes, utiliza um m√©todo 
estat√≠stico simples para reconhecer padr√µes. O algoritmo Naive Bayes 
assume que existe uma independ√™ncia entre os dados que ser√° dado como 
entrada para treinamento, no nosso caso, cada palavra ser√° independente 
uma da outra e a presen√ßa ou n√£o de uma no coment√°rio n√£o est√° 
relacionada com qualquer outra palavra.</p>

<p>‚ÄúEm um processo de classifica√ß√£o no qual um exemplar com classe 
desconhecida seja apresentado, o Naive Bayes tomar√° a decis√£o sobre qual 
√© a classe daquele exemplar, por meio do c√°lculo de probabilidades 
condicionais. Ele faz isso calculando as probabilidades de ele pertencer 
√† cada uma das diferentes classes existentes no conjunto de treinamento 
e ent√£o classifica o exemplar pela classe com maior probabilidade.‚Äù <a href="http://joseguilhermelopes.com.br/naive-bayes-conceito-aplicacoes-implementacao-r/"><em>Fonte</em></a></p>

<p>Ap√≥s o pr√©-processamento temos os dados limpos, consistentes, podemos 
envi√°-los como entrada para o treinamento do algoritmo escolhido. 
O algoritmo tentar√° localizar padr√µes e caracter√≠sticas que mapeiam o 
coment√°rio para sua classe j√° definida.</p>

<p>O naive bayes entende cada texto como algo chamando <em>bag-of-words</em>, que 
representa a frequ√™ncia que cada palavra aparece no texto. Tomando como 
exemplo os coment√°rios: <code class="language-plaintext highlighter-rouge">"que filme ruim"</code> e <code class="language-plaintext highlighter-rouge">"filme muito ruim, n√£o gostei"</code> 
como negativo e <code class="language-plaintext highlighter-rouge">"muito bom, gostei muito desse filme"</code> como positivo, 
gerando a <em>bag-of-words</em> de todos os coment√°rios temos o seguinte:</p>

<p><code class="language-plaintext highlighter-rouge">["que", "ruim", "filme", "muito", "n√£o", "gostei", "desse", "bom"]</code></p>

<p>Assim, podemos representar os coment√°rios de exemplo como uma frequ√™ncia 
de palavras:</p>

<table>
  <thead>
    <tr>
      <th>Coment√°rio/Palavra</th>
      <th>que</th>
      <th>ruim</th>
      <th>filme</th>
      <th>muito</th>
      <th>n√£o</th>
      <th>gostei</th>
      <th>desse</th>
      <th>bom</th>
      <th>Classe</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>que filme ruim</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>Negativo</td>
    </tr>
    <tr>
      <td>filme muito ruim, n√£o gostei</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>Negativo</td>
    </tr>
    <tr>
      <td>muito bom, gostei muito desse filme</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>Positivo</td>
    </tr>
  </tbody>
</table>

<p>Dessa forma, o algoritmo calcula a probabilidade de cada palavra 
pertencer a cada classe, nesse exemplo simples, podemos perceber que a palavra 
‚Äúruim‚Äù tem uma maior probabilidade de ser da classe Negativo.</p>

<p><br /></p>

<h3 id="teste-e-avalia√ß√£o"><strong>Teste e avalia√ß√£o</strong></h3>
<div class="img-container">
    <img src="https://image.ibb.co/nGAgzo/test.png" />
</div>

<p>Uma parte dos dados de treinamento √© separado, e n√£o utilizados na etapa 
anterior, para servir como dados de teste, ap√≥s o treinamento, esses 
dados s√£o enviados para o algoritmo para que seja feito a classifica√ß√£o 
dos mesmos pelo algoritmo treinado, esses dados de teste n√£o devem ser 
nenhum dos mesmos utilizados na etapa de treinamento. Ap√≥s o teste 
normalmente temos algumas informa√ß√µes de desempenho do algoritmo como, 
por exemplo, a acur√°cia, quantidade de falsos positivos e falsos 
negativos, entre outras.</p>

<p>Com essas informa√ß√µes podemos e devemos analisar a qualidade do 
treinamento e do algoritmo e perceber se atende o objetivo final, 
como Machine Learning √© um processo emp√≠rico, caso n√£o atenda a 
necessidade, podemos realizar a escolha de um outro algoritmo e proceder 
com as etapas de treinamento, teste e avalia√ß√£o novamente at√© que se 
encontre alguma t√©cnica que resulte em m√©tricas aceit√°veis para o 
problema.</p>

<p><br />
<br /></p>

<h3 id="lets-code"><strong>Let‚Äôs code</strong></h3>

<p>Primeiramente vamos criar um projeto novo usando o Leiningen.<br />
Caso n√£o saiba como criar um projeto em clojure, tem um artigo com uma
introdu√ß√£o para cria√ß√£o projetos e depend√™ncias em Clojure:</p>
<div id="ref-post">
    <a href="/2018/Clojure-Leiningen/">
        <img src="https://cdn-images-1.medium.com/max/1371/1*6h-IqXpvLbQemIRedaCrMg.png" />
        <div id="link-title">
            Clojure - Leiningen
        </div>
        <div id="link-description">
            Em projetos de software, sejam grandes ou pequenos, pela
            facilidade e otimiza√ß√£o do tempo, busca-se a reutiliza√ß√£o de
            c√≥digo, isso inclui tamb√©m a utiliza√ß√£o...
        </div>
    </a>
</div>

<p><br /></p>

<p>No terminal vamos executar o seguinte comando:</p>

<p><code class="language-plaintext highlighter-rouge">
lein run
</code></p>

<p>Iremos utilizar duas bibliotecas para auxiliar o desenvolvimento, a 
snowball-stemmer e a clj-ml. A snowball tem uma fun√ß√£o de stemming e 
suporte ao idioma portugu√™s, e a clj-ml √© uma lib de machine learning, 
tem algumas fun√ß√µes e algoritmos prontos para n√≥s usarmos. Ent√£o vamos 
adicion√°-las como depend√™ncias no arquivo project.clj.<br />
<script src="https://gist.github.com/Jciel/1802748d4d6ce76721c66fb8b782bd7a.js"></script></p>

<p>Ap√≥s, dentro do diret√≥rio raiz do projeto, vamos executar o comando para 
instalar as dep√™ndencias.<br />
<code class="language-plaintext highlighter-rouge">
lein deps
</code></p>

<p>Para separar as fun√ß√µes, iremos criar um novo arquivo chamado 
pre-processing dentro do diret√≥rio src/comment_analysis, nesse arquivo 
ir√° ficar as fun√ß√µes de pr√©-processamento dos coment√°rios.<br />
<script src="https://gist.github.com/Jciel/eef7e04389cfbd84d60f8cef6b322ac2.js"></script></p>

<p>No in√≠cio do arquivo vamos definir o namespace e fazemos os requires dos 
namespaces que iremos usar <code class="language-plaintext highlighter-rouge">(linha 1)</code>.</p>

<p>Definimos uma fun√ß√£o <code class="language-plaintext highlighter-rouge">stems</code> usando a lib snowball <code class="language-plaintext highlighter-rouge">(linha 6)</code>.</p>

<p>Logo ap√≥s temos a <code class="language-plaintext highlighter-rouge">fun√ß√£o get-stemmin-words</code>, que recebe um coment√°rio, 
cria um vetor das palavras e faz o processo de stemming em cada palavra 
do coment√°rio <code class="language-plaintext highlighter-rouge">(linha 8)</code>.</p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">remove-stop-words</code> √© respons√°vel por fazer a remo√ß√£o das 
stop-words do coment√°rio que recebe por par√¢metro <code class="language-plaintext highlighter-rouge">(linha 22)</code>.</p>

<p>A <code class="language-plaintext highlighter-rouge">deaccent</code> remove as acentua√ß√µes das palavras, deixando as letras sem 
acentos <code class="language-plaintext highlighter-rouge">(linha 26)</code>.</p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">remove-punctuation-and-symbols</code> faz o processo de remo√ß√£o de 
pontua√ß√µes e alguns simbolos e caracteres <code class="language-plaintext highlighter-rouge">(linha 33)</code>.</p>

<p>Ap√≥s temos a fun√ß√£o <code class="language-plaintext highlighter-rouge">remove-unnecessary-spaces</code> que remove os espa√ßos 
extras que tiverem no coment√°rio, deixando apenas um espa√ßo onde deva 
ter <code class="language-plaintext highlighter-rouge">(linha 37)</code>.</p>

<p>Temos a fun√ß√£o <code class="language-plaintext highlighter-rouge">remove-excess-characters</code> que remove os caracteres 
excess√≠vos, por exemplo a palavra ‚Äúmuuuuuito‚Äù vira ‚Äúmuito‚Äù <code class="language-plaintext highlighter-rouge">(linha 41)</code>.</p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">make-bag-of-words</code> criar√° a nossa lista de todas as palavras 
existentes no datasset, essa lista ser√° utilizada para na cria√ß√£o do 
algoritmo de classifica√ß√£o e prepara√ß√£o dos dataset de treinamento e 
teste <code class="language-plaintext highlighter-rouge">(linha 45)</code>.</p>

<p>Ap√≥s temos a fun√ß√£o <code class="language-plaintext highlighter-rouge">prepare-dataset</code> que ir√° preparar o nosso dataset 
antes de ser usado para o treinamento e teste do nosso algoritmo <code class="language-plaintext highlighter-rouge">(linha 53)</code>.</p>

<p>E a fun√ß√£o ‚Äúprincipal‚Äù <code class="language-plaintext highlighter-rouge">preprocess</code> que na pr√°tica executa as outras 
fun√ß√µes em sequ√™ncia passando o coment√°rio que recebe por par√¢mentro.</p>

<p><br /></p>

<p>No arquivo <code class="language-plaintext highlighter-rouge">core.clj</code> iremos escrever nosso c√≥digo para preparar os 
coment√°rios, montar nosso datasset para ser usado para treinamento e 
teste do algoritmo. Primeiramente vamos fazer o require dos namespaces.<br />
<script src="https://gist.github.com/Jciel/e7c3af1943b9c6953f967c5c8506e24b.js"></script></p>

<p><br /></p>

<p>Ap√≥s vamos criar duas fun√ß√µes para fazer a leitura dos arquivos que 
cont√©m os coment√°rios, esses arquivos estar√£o em um diret√≥rio comments 
na raiz do projeto.<br />
<script src="https://gist.github.com/Jciel/926fb20199c612a2adc8efd2ca0bf300.js"></script></p>

<p><br /></p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">get-comment-and-class</code> recebe uma string do coment√°rio e sua 
classe e retorna um map separando o coment√°rio da classe, j√° passado pelo 
pr√©-processamento, no formato.<br />
<code class="language-plaintext highlighter-rouge">{:comment comentario :class class}</code>
<script src="https://gist.github.com/Jciel/f648d5cbd73d572eb26d2c61f68eb33a.js"></script></p>

<p><br /></p>

<p>A pr√≥xima fun√ß√£o <code class="language-plaintext highlighter-rouge">get-frequencies-words</code> recebe uma estrutura gerada pela 
fun√ß√£o <code class="language-plaintext highlighter-rouge">get-comment-and-class</code> e retorna um map com cada palavra, j√° 
passado pelo processo de stemming, como chave e a quantidade dessa 
palavra no coment√°rio como valor, al√©m da classe do coment√°rio.<br />
<script src="https://gist.github.com/Jciel/814f4bd53b8518b1d75360fda0bfc739.js"></script></p>

<p>Por exemplo, o coment√°rio: <code class="language-plaintext highlighter-rouge">clj {:class 0¬†:comment "eu nao gostei desse filme"}</code> 
ao ser passado para a fun√ß√£o get-frequencies-words retorna a seguinte 
estrutura.<br />
<code class="language-plaintext highlighter-rouge">
{
    :class 0
    :eu 1
    :nao 1
    :gost 1
    :desse 1
    :film 1
}
</code></p>

<p><br /></p>

<p>As duas fun√ß√µes seguintes s√£o usadas para construir um vetor de map com 
a quantidade das palavras de todos os coment√°rios, esse processo executa 
separado para os coment√°rios positivos e para os negativos.<br />
<script src="https://gist.github.com/Jciel/6fab9fc7cdf4efb62b3f00e9989bfcc5.js"></script></p>

<p>Usando o mesmo coment√°rio anterior como exemplo, essa fun√ß√£o retorna o 
seguinte vetor.<br />
<code class="language-plaintext highlighter-rouge">[{:class 0 :eu 1 :nao 1 :gost 1 :desse 1 :film 1} ...]</code></p>

<p><br /></p>

<p>Como citado acima, uma parte dos dados de dataset √© separado para treino 
e outra para teste, a fun√ß√£o <code class="language-plaintext highlighter-rouge">divide-dataset</code> faz esse processo. A fun√ß√£o 
recebe o vetor retornado pelas fun√ß√µes <code class="language-plaintext highlighter-rouge">define-data-words-*</code> e divide em 
~70% dos itens para treino e os outros ~30% para teste.<br />
<script src="https://gist.github.com/Jciel/17dc5deec58beceb39c5c137f02c55e4.js"></script></p>

<p>Essa fun√ß√£o retorna tamb√©m um map no seguinte formato:<br />
<code class="language-plaintext highlighter-rouge">
{
    :train [{:class 0 :eu 1 :nao 1 :gostei 1 :desse 1 :filme 1} ...}]
    :test [{...} {...}]
}
</code></p>

<p><br /></p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">define-data-words</code> cria o conjunto de dados para treino e teste 
chamando as fun√ß√µes anteriores e fazendo a uni√£o dos dados referente aos 
coment√°rios negativos e positivos para treino e teste, para ser mais 
aleat√≥rio embaralho os dados usando a fun√ß√£o <code class="language-plaintext highlighter-rouge">shuffle</code>.<br />
<script src="https://gist.github.com/Jciel/38612cba739537e3b296a9b1cf6cb062.js"></script></p>

<p>Retornando uma estrutura semelhante a anterior, mas com todos os dados 
dos coment√°rios positivos e negativos no mesmo vetor.<br />
<code class="language-plaintext highlighter-rouge">
{
    :train [{:class 0 :eu 1 :nao 1 :gostei 1 :desse 1 :filme 1} ...}]
    :test [{...} {...}]
}
</code></p>

<p><br /></p>

<p>Temos as fun√ß√µes para criar os datasets de treino e teste utilizando as 
fun√ß√µes da lib <code class="language-plaintext highlighter-rouge">clj-ml</code>, criando o dataset, aplicando filtro no atributo 
referente a classe do coment√°rio e definindo esse atributo como classe.<br />
<script src="https://gist.github.com/Jciel/9bb190534eda5585f00a483b94ccaddc.js"></script></p>

<p><br /></p>

<p>E a fun√ß√£o que realiza o treinamento do classificador e a avalia√ß√£o do 
mesmo, logo ap√≥s imprime as informa√ß√µes de desempenho do algoritmo.<br />
<script src="https://gist.github.com/Jciel/822bb2ba0c296b8da4f8a93f7510ab60.js"></script></p>

<p><br /></p>

<p>A fun√ß√£o <code class="language-plaintext highlighter-rouge">main</code> quando chamada realiza as chamadas para as outras fun√ß√µes 
para cria√ß√£o dos datasets e ap√≥s chama a fun√ß√£o de treinamento e avalia√ß√£o 
do classificador, assim mostrando as informa√ß√µes de desempenho do algoritmo.<br />
<script src="https://gist.github.com/Jciel/3966176e1e7f7401053346e03bf9e4b6.js"></script></p>

<p><br /></p>

<p>Entrando no diret√≥rio raiz do projeto e executando o comando <code class="language-plaintext highlighter-rouge">lein run</code> 
para iniciar a execu√ß√£o do c√≥digo. Inicia o processo de prepara√ß√£o, 
treinamento e teste do algoritmo utilizado, assim que acabar ir√° mostrar 
os resultados da avalia√ß√£o.</p>

<p>As informa√ß√µes retornadas ser√£o semelhantes a estas:<br />
<script src="https://gist.github.com/Jciel/c942b238fe75e04e80135ea45e67ed0b.js"></script></p>

<p>Destaque para o sum√°rio <code class="language-plaintext highlighter-rouge">(linha 33)</code>, que nos mostra a quantidade e 
porcentagem de coment√°rios classificados corretamente e incorretamente, 
o total de coment√°rios utilizado para o teste. Tamb√©m temos a matrix de 
confus√£o <code class="language-plaintext highlighter-rouge">(linha 55)</code> que mostra quantos coment√°rios foram classificados 
como positivos <code class="language-plaintext highlighter-rouge">(1)</code> e negativos <code class="language-plaintext highlighter-rouge">(0)</code>.</p>

<p>No exemplo podemos identificar que de 396 coment√°rios negativos ele 
classificou 300 como negativos (correto) e 96 como positivos (incorreto) 
e de 396 coment√°rios positivos ele classificou 210 como positivo (correto) 
e 186 como negativo (incorreto). Podemos perceber que est√° acertando 
mais os coment√°rios negativos do que os positivos. Assim podemos avaliar 
as m√©tricas necess√°rias e definir se atende as necessidades do problema 
em que ser√° aplicado.</p>

<p><br /></p>

<h3 id="conclus√£o-e-observa√ß√µes"><strong>Conclus√£o e observa√ß√µes</strong></h3>
<p>No caso de estudo foi usado Machine Learning para classifica√ß√£o de 
coment√°rios sobre filmes, esses coment√°rios foram retirados de um site 
sobre cinema usando webscraping e salvos em arquivos de textos, para 
definir de qual classe os coment√°rios eram, Positivo (1) e Negativo (0) 
foi utilizado a nota dada, tamb√©m no respectivo site, foi assumido notas 
4 e 5 como um coment√°rio Positivo e notas igual ou abaixo de 2 como um 
coment√°rio Negativo.<br />
Foi usado um total 2634 coment√°rios, metade negativos e metade 
positivos, foi usado o algoritmo Naive Bayes como classificador e 
utilizado ~70% dos coment√°rios de cada classe para treinamento e os 
outros ~30% para teste. Ap√≥s o treinamento e teste devemos observar as 
m√©tricas e avaliar se s√£o aceit√°veis e atendem o problema em que ser√° 
aplicado.</p>

<ul>
  <li>
    <p>Durante o processo de captura dos dados foi notado que, mesmo alguns 
coment√°rios visivelmente positivos estavam com nota baixa e consequentemente 
entraram como coment√°rios negativos, o oposto tamb√©m foi observado. Casos 
assim podem causar inconsist√™ncia no treinamento do algoritmo ocorrendo 
uma baixa qualidade nos resultados de teste, a qualidade do dataset tem 
enorme influ√™ncia nos resultados finais.</p>
  </li>
  <li>
    <p>O processo de remo√ß√£o de <em>stopwords</em> e <em>stemming</em> tamb√©m pode influenciar 
no treinamento, a lista de palavras consideradas como <em>stopwords</em> tem de 
ser avaliada e observado se n√£o est√° removendo palavras que tenham 
import√¢ncia para o contexto, realizei alguns testes com e sem o processo 
de <em>stemming</em> e remo√ß√£o de <em>stopwords</em> e o melhor resultado ocorreu deixando 
os dois processos.</p>
  </li>
</ul>

<p><br /></p>

<p>O c√≥digo completo podem ver <a href="https://github.com/Jciel/comment-analysis">aqui</a></p>

<p>D√∫vidas, sugest√µes, cr√≠ticas‚Ä¶ podem deixar nos coment√°rios, e compartilhar caso gostou :D.</p>

<p><br />
<br /></p>

<h5 id="refer√™ncias"><strong>Refer√™ncias:</strong></h5>
<ul>
  <li>http://bdm.unb.br/bitstream/10483/11042/1/2015_LucasBragaRibeiro.pdf</li>
  <li>https://www.maxwell.vrac.puc-rio.br/13212/13212_4.PDF</li>
  <li>https://www.infoq.com/br/presentations/classificacao-de-documentos-baseada-em-inteligencia-artificial</li>
  <li>https://www.safaribooksonline.com/library/view/clojure-for-data/9781784397180/ch04s13.html</li>
  <li>https://pt.slideshare.net/jonmagal/naive-bayes-16122964</li>
  <li>https://pt.slideshare.net/plataformatec/classificao-de-textos-dev-in-sampa-28nov2009</li>
  <li>https://pt.slideshare.net/matheusgaldino355/teoria-decisao-bayes</li>
  <li>https://gabrielschade.github.io/2018/04/16/machine-learning-classificador.html</li>
</ul>

:ET